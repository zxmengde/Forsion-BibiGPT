import { extractSentenceWithTimestamp } from '~/utils/extractSentenceWithTimestamp'
import { extractTimestamp } from '~/utils/extractTimestamp'
import { validateAndFixTimestamp, timeStringToSeconds } from '~/utils/videoDuration'

/**
 * 规范化时间戳格式，补齐单位数的分钟或秒数
 * 例如：8:0 -> 8:00, 1:2:3 -> 1:02:03
 */
function normalizeTimestamp(timestamp: string): string {
  const parts = timestamp.split(':')
  if (parts.length === 2) {
    // MM:SS 格式
    const minutes = parts[0]
    const seconds = parts[1].padStart(2, '0')
    return `${minutes}:${seconds}`
  } else if (parts.length === 3) {
    // HH:MM:SS 格式
    const hours = parts[0]
    const minutes = parts[1].padStart(2, '0')
    const seconds = parts[2].padStart(2, '0')
    return `${hours}:${minutes}:${seconds}`
  }
  return timestamp
}

export interface TimeSegment {
  timestamp: string
  summary: string
  details: string
  fullContent: string
}

// 新的结构化总结数据类型
export interface HighlightItem {
  emoji?: string
  timestamp?: string
  content: string
}

export interface ReflectionItem {
  question: string
  answer: string
  timestamp?: string
}

export interface TermExplanation {
  term: string
  explanation: string
}

export interface TimelineItem {
  timestamp: string
  content: string
  screenshot?: string // 截图URL或标注
}

export interface StructuredSummary {
  topic: string // 视频主题
  summary: string // 摘要
  highlights: HighlightItem[] // 亮点（带emoji+时间戳）
  reflections: ReflectionItem[] // 思考（带问题+解答+时间戳）
  terms: TermExplanation[] // 术语解释
  timeline: TimelineItem[] // 时间线总结（分时间点+内容+截图标注）
}

/**
 * a summary generated by ChatGPT
 *
 * @export
 * @param {string} summary
 * @return {*}  {{
 *   summaryArray: string[],
 *   formattedSummary: string
 * }}
 */
export function formatSummary(summary: string): {
  summaryArray: string[]
  formattedSummary: string
} {
  /*
  if (shouldShowTimestamp) {
    try {
      const parsedBulletPoints = JSON.parse(summary);
      const summaryArray = parsedBulletPoints.map(
        ({ s, bullet_point }: { s: number; bullet_point: string }) => {
          const startTime = s === 0 ? "0.0" : s;
          return startTime + " " + bullet_point;
        }
      );
      return {
        summaryArray,
        formattedSummary: summaryArray.join("\n"),
      };
    } catch (e) {
      console.error(e);
      return {};
    }
  }
*/

  const summaryArray: string[] = summary.split('\n- ')
  const formattedSummary: string = summaryArray
    .map((s) => {
      const matchTimestampResult = extractSentenceWithTimestamp(s)
      if (matchTimestampResult) {
        const { formattedContent, timestamp } = extractTimestamp(matchTimestampResult)
        return timestamp + formattedContent
      } else {
        return s.replace(/\n\n/g, '\n')
      }
    })
    .join('\n- ')
  return { summaryArray, formattedSummary }
}

/**
 * 解析总结内容，将每个时间段分成总结和详细描述两部分
 * @param summary 原始总结文本
 * @returns 时间段数组，包含时间戳、总结和详细描述
 */
export function parseSummaryWithDetails(summary: string): TimeSegment[] {
  const summaryArray = summary.split('\n- ').filter((s) => s.trim().length > 0)

  return summaryArray
    .map((sentence) => {
      const matchResult = extractSentenceWithTimestamp(sentence)

      if (matchResult) {
        const timestampStr = matchResult[1] // 原始时间戳，如 "0:10" 或 "1:23:45"
        const content = matchResult[2] || ''

        // 格式化时间戳（确保格式一致）
        let formattedTimestamp = timestampStr
        const parts = timestampStr.split(':')
        if (parts.length === 2) {
          // 格式: MM:SS，保持不变
          formattedTimestamp = timestampStr
        } else if (parts.length === 3) {
          // 格式: HH:MM:SS，保持不变
          formattedTimestamp = timestampStr
        }

        // 尝试将内容分成总结和详细描述
        // 如果内容中有换行，第一行作为总结，其余作为详细描述
        // 如果内容中有句号或分号，前面部分作为总结，后面部分作为详细描述
        let summaryText = content.trim()
        let detailsText = ''

        // 检查是否有换行符
        if (content.includes('\n')) {
          const lines = content.split('\n').filter((line) => line.trim().length > 0)
          summaryText = lines[0]?.trim() || content.trim()
          detailsText = lines.slice(1).join('\n').trim()
        }
        // 检查是否有明显的分隔符（如：、。、；等）
        else if (content.includes('：') || content.includes(':')) {
          const separatorIndex = content.indexOf('：') !== -1 ? content.indexOf('：') : content.indexOf(':')
          summaryText = content.substring(0, separatorIndex + 1).trim()
          detailsText = content.substring(separatorIndex + 1).trim()
        }
        // 如果内容较长，尝试在第一个句号处分割
        else if (content.length > 50 && content.includes('。')) {
          const periodIndex = content.indexOf('。')
          summaryText = content.substring(0, periodIndex + 1).trim()
          detailsText = content.substring(periodIndex + 1).trim()
        }

        // 如果详细描述为空，将整个内容作为总结
        if (!detailsText) {
          summaryText = content.trim()
          detailsText = ''
        }

        return {
          timestamp: formattedTimestamp,
          summary: summaryText,
          details: detailsText,
          fullContent: content.trim(),
        }
      }

      // 如果没有时间戳，返回空的时间段
      return {
        timestamp: '',
        summary: sentence.trim(),
        details: '',
        fullContent: sentence.trim(),
      }
    })
    .filter((segment) => segment.timestamp || segment.summary)
}

/**
 * 解析新的结构化总结内容
 * 格式示例：
 * ## 视频主题
 * [主题内容]
 *
 * ## 摘要
 * [摘要内容]
 *
 * ## 亮点
 * - [时间戳] [emoji] [亮点内容]
 *
 * ## 思考
 * - [时间戳] 问题：[问题内容]
 *   解答：[解答内容]
 *
 * ## 术语解释
 * - [术语]：[解释]
 *
 * ## 时间线总结
 * - [时间戳] [内容] [截图标注]
 *
 * @param summary 总结文本
 * @param maxDurationSeconds 视频最大时长（秒数），用于校验时间点
 */
export function parseStructuredSummary(summary: string, maxDurationSeconds?: number): StructuredSummary {
  const result: StructuredSummary = {
    topic: '',
    summary: '',
    highlights: [],
    reflections: [],
    terms: [],
    timeline: [],
  }

  // 清理输入文本，移除可能的引号和转义字符
  let cleanSummary = summary
  if (cleanSummary.startsWith('"') && cleanSummary.endsWith('"')) {
    cleanSummary = cleanSummary.substring(1, cleanSummary.length - 1)
  }
  cleanSummary = cleanSummary.replace(/\\n/g, '\n')

  // 如果总结中没有换行符，但包含 markdown 标题，尝试添加换行符
  // 这是为了处理 AI 生成时没有正确添加换行符的情况
  if (!cleanSummary.includes('\n') && cleanSummary.includes('##')) {
    // 1. 在 markdown 标题前添加换行符（除了第一个）
    cleanSummary = cleanSummary.replace(/([^\n])(##\s+)/g, '$1\n$2')
    // 2. 在已知章节标题关键词后添加换行符（例如 "## 亮点✨ content" → "## 亮点\n✨ content"）
    cleanSummary = cleanSummary.replace(/(##\s+(?:视频主题|摘要|亮点|思考|术语解释|时间线))\s*(?!\n)/g, '$1\n')
    // 3. 在 emoji 前添加换行符（如果前面不是换行符或标题）
    cleanSummary = cleanSummary.replace(/([^\n])([\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}])/gu, '$1\n$2')
    // 4. 在时间戳后添加换行符（如果后面是 emoji 或新内容）
    cleanSummary = cleanSummary.replace(/(\d{1,2}:\d{1,2})\s+([\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}])/gu, '$1\n$2')
    // 5. 在标签行前添加换行符
    cleanSummary = cleanSummary.replace(/([^\n])(#\w+)/g, '$1\n$2')
    // 6. 清理多余的连续换行符
    cleanSummary = cleanSummary.replace(/\n{3,}/g, '\n\n')
  }

  // 提取视频主题
  const topicMatch = cleanSummary.match(/##\s*视频主题\s*\n+([\s\S]*?)(?=\n+##|$)/i)
  if (topicMatch) {
    result.topic = topicMatch[1].trim().replace(/^-\s*/, '') // 移除可能的列表符号
  }

  // 提取摘要（完整段落，不是列表）
  const summaryMatch = cleanSummary.match(/##\s*摘要\s*\n+([\s\S]*?)(?=\n+##|$)/i)
  if (summaryMatch) {
    result.summary = summaryMatch[1]
      .trim()
      .replace(/^[-•]\s*/, '')
      .replace(/^[0-9]+[\.\)]\s*/, '')
  }

  // 提取亮点（格式：emoji 内容 时间戳在末尾，最后一行是标签）
  const highlightsMatch = cleanSummary.match(/##\s*亮点\s*\n+([\s\S]*?)(?=\n+##|$)/i)
  if (highlightsMatch) {
    const highlightsText = highlightsMatch[1]
    const lines = highlightsText.split('\n').filter((line) => line.trim())

    lines.forEach((line) => {
      const trimmed = line.trim()

      // 跳过标签行（以#开头）
      if (trimmed.startsWith('#')) {
        return
      }

      // 匹配格式：emoji 内容 时间戳（时间戳可能在末尾，也可能是括号格式如 (00:45)）
      // 扩展emoji匹配范围
      const emojiPattern =
        /^([\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}\u{1F600}-\u{1F64F}\u{1F680}-\u{1F6FF}\u{1F900}-\u{1F9FF}\u{1FA00}-\u{1FA6F}])/u
      // 支持多种时间戳格式：
      // 1. 末尾的 00:45 或 HH:MM:SS
      // 2. 括号格式 (00:45)
      // 3. 4位数字格式 0830 (MMSS)
      const timestampPatternEnd = /(\d{1,2}:\d{1,2}(?::\d{1,2})?)\s*$/ // 末尾格式：00:45 或 8:0
      const timestampPatternBracket = /\((\d{1,2}:\d{1,2}(?::\d{1,2})?)\)/g // 括号格式：(00:45) 或 (8:0)
      const timestampPattern4Digits = /(\d{4})\s*$/ // 4位数字格式：0830 (MMSS)

      const emojiMatch = trimmed.match(emojiPattern)
      const timestampMatchEnd = trimmed.match(timestampPatternEnd)
      const timestampMatchBracket = [...trimmed.matchAll(timestampPatternBracket)]
      const timestampMatch4Digits = trimmed.match(timestampPattern4Digits)

      const emoji = emojiMatch ? emojiMatch[1] : undefined
      // 优先使用末尾的时间戳，如果没有则使用括号中的最后一个，最后尝试4位数字格式
      let timestamp = timestampMatchEnd ? timestampMatchEnd[1] : undefined
      if (!timestamp && timestampMatchBracket.length > 0) {
        // 使用最后一个括号中的时间戳
        timestamp = timestampMatchBracket[timestampMatchBracket.length - 1][1]
      }
      if (!timestamp && timestampMatch4Digits) {
        // 4位数字格式：0830 -> 08:30
        const digits = timestampMatch4Digits[1]
        timestamp = `${digits.substring(0, 2)}:${digits.substring(2)}`
      }

      // 移除emoji和时间戳，获取内容
      let content = trimmed
      if (emoji) {
        content = content.replace(emoji, '').trim()
      }
      if (timestamp) {
        // 移除末尾的时间戳格式（包括 MM:SS 和 4位数字格式）
        content = content.replace(new RegExp(timestamp.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*$'), '').trim()
        // 移除括号格式的时间戳
        content = content
          .replace(new RegExp('\\(\\s*' + timestamp.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*\\)', 'g'), '')
          .trim()
        // 移除4位数字格式的时间戳（如果存在）
        if (timestampMatch4Digits) {
          content = content
            .replace(new RegExp(timestampMatch4Digits[1].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*$'), '')
            .trim()
        }
      }

      // 清理多余的空格
      content = content.trim()

      // 规范化时间戳格式（补齐单位数秒，如 8:0 -> 8:00）
      if (timestamp) {
        timestamp = normalizeTimestamp(timestamp)
      }

      // 校验并修正时间戳（如果提供了视频时长）
      let validatedTimestamp = timestamp
      if (timestamp && maxDurationSeconds) {
        const fixed = validateAndFixTimestamp(timestamp, maxDurationSeconds, true)
        validatedTimestamp = fixed || undefined
      }

      if (content) {
        result.highlights.push({
          timestamp: validatedTimestamp,
          emoji,
          content: content,
        })
      }
    })
  }

  // 提取思考（格式：问题作为标题，解答内容，时间戳在解答末尾）
  const reflectionsMatch = cleanSummary.match(/##\s*思考\s*\n+([\s\S]*?)(?=\n+##|$)/i)
  if (reflectionsMatch) {
    const reflectionsText = reflectionsMatch[1]
    const lines = reflectionsText.split('\n').filter((line) => line.trim())

    let currentReflection: Partial<ReflectionItem> | null = null

    lines.forEach((line) => {
      const trimmed = line.trim()

      // 检查是否是问题（不以"问题："开头，但可能是新问题的开始）
      // 如果当前没有问题，或者上一行是空行/解答结束，这可能是新问题
      if (!currentReflection || (currentReflection.question && currentReflection.answer)) {
        // 保存之前的思考项
        if (currentReflection && currentReflection.question) {
          result.reflections.push(currentReflection as ReflectionItem)
        }
        // 新问题开始（不包含"问题："或"解答："前缀，且不是时间戳）
        if (trimmed && !trimmed.match(/解答[：:]/) && !trimmed.match(/^\d{1,2}:\d{1,2}/)) {
          currentReflection = {
            question: trimmed,
            answer: '',
            timestamp: undefined,
          }
        }
      } else if (currentReflection && currentReflection.question) {
        // 这是解答内容
        // 检查时间戳是否在末尾
        const timestampMatch = trimmed.match(/(\d{1,2}:\d{1,2}(?::\d{1,2})?)\s*$/)
        if (timestampMatch) {
          let timestamp = normalizeTimestamp(timestampMatch[1])
          // 校验并修正时间戳（如果提供了视频时长）
          if (maxDurationSeconds) {
            const fixed = validateAndFixTimestamp(timestamp, maxDurationSeconds, true)
            timestamp = fixed || timestamp
          }
          currentReflection.timestamp = timestamp
          // 移除时间戳
          const answerWithoutTimestamp = trimmed
            .replace(new RegExp(timestampMatch[1].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + '\\s*$'), '')
            .trim()
          currentReflection.answer =
            (currentReflection.answer || '') + (currentReflection.answer ? ' ' : '') + answerWithoutTimestamp
        } else {
          currentReflection.answer = (currentReflection.answer || '') + (currentReflection.answer ? ' ' : '') + trimmed
        }
      }
    })

    // 保存最后一个思考项
    if (currentReflection && currentReflection.question) {
      result.reflections.push(currentReflection as ReflectionItem)
    }
  }

  // 提取术语解释（格式：术语：解释，每行一个，不是列表）
  const termsMatch = cleanSummary.match(/##\s*术语解释\s*\n+([\s\S]*?)(?=\n+##|$)/i)
  if (termsMatch) {
    const termsText = termsMatch[1]
    const termLines = termsText.split('\n').filter((line) => {
      const trimmed = line.trim()
      return trimmed && (trimmed.includes('：') || trimmed.includes(':'))
    })

    termLines.forEach((line) => {
      const trimmed = line.trim()
      // 匹配格式：术语：解释 或 术语: 解释（不一定是列表格式）
      const termMatch = trimmed.match(/^([^：:]+)[：:]\s*(.+)/)
      if (termMatch) {
        result.terms.push({
          term: termMatch[1].trim(),
          explanation: termMatch[2].trim(),
        })
      }
    })
  }

  // 提取时间线总结（格式：时间戳 - emoji 标题，然后是"Screenshot at Xs"，然后是详细描述）
  const timelineMatch = cleanSummary.match(/##\s*时间线总结\s*\n+([\s\S]*?)(?=\n+##|$)/i)
  if (timelineMatch) {
    const timelineText = timelineMatch[1]
    const lines = timelineText.split('\n')

    let currentItem: Partial<TimelineItem> | null = null

    lines.forEach((line) => {
      const trimmed = line.trim()

      // 匹配时间戳行：格式 "时间戳 - emoji 标题"
      const timestampLineMatch = trimmed.match(/^(\d{1,2}:\d{1,2}(?::\d{1,2})?)\s*-\s*(.+)/)
      if (timestampLineMatch) {
        // 保存之前的项
        if (currentItem && currentItem.timestamp && currentItem.content) {
          result.timeline.push(currentItem as TimelineItem)
        }

        let timestamp = timestampLineMatch[1]
        // 校验并修正时间戳（如果提供了视频时长）
        if (maxDurationSeconds) {
          const fixed = validateAndFixTimestamp(timestamp, maxDurationSeconds, true)
          timestamp = fixed || timestamp
        }
        const titleWithEmoji = timestampLineMatch[2].trim()

        currentItem = {
          timestamp,
          content: titleWithEmoji,
          screenshot: undefined,
        }
      }
      // 匹配截图行：格式 "Screenshot at Xs"
      else if (trimmed.match(/^Screenshot\s+at\s+(\d+)s?$/i)) {
        const screenshotMatch = trimmed.match(/^Screenshot\s+at\s+(\d+)s?$/i)
        if (screenshotMatch && currentItem) {
          currentItem.screenshot = `Screenshot at ${screenshotMatch[1]}s`
        }
      }
      // 其他行作为详细描述内容
      else if (trimmed && currentItem && currentItem.timestamp) {
        // 如果已经有内容，追加
        const existingContent = currentItem.content || ''
        if (existingContent && !existingContent.includes(trimmed)) {
          // 避免重复添加标题
          const titleMatch = existingContent.match(/^(.+?)(?:\n|$)/)
          if (titleMatch && trimmed !== titleMatch[1]) {
            currentItem.content = existingContent + '\n\n' + trimmed
          } else if (!titleMatch) {
            currentItem.content = existingContent + '\n\n' + trimmed
          }
        } else if (!existingContent) {
          currentItem.content = trimmed
        }
      }
    })

    // 保存最后一个项
    if (currentItem && currentItem.timestamp && currentItem.content) {
      result.timeline.push(currentItem as TimelineItem)
    }
  }

  return result
}

/**
 * 将结构化总结数据转换为思维导图 markdown 格式
 * @param structuredData 结构化总结数据
 * @returns 思维导图 markdown 字符串
 */
export function structuredSummaryToMindMapMarkdown(structuredData: StructuredSummary): string {
  const lines: string[] = []

  // 根节点：视频主题或摘要
  const rootTitle = structuredData.topic || '视频总结'
  lines.push(`# ${rootTitle}`)

  // 摘要分支
  if (structuredData.summary) {
    lines.push('')
    lines.push('## 摘要')
    // 将摘要按句号分割，每句作为子节点
    const summarySentences = structuredData.summary
      .split(/[。！？\n]/)
      .map((s) => s.trim())
      .filter((s) => s.length > 0)
    if (summarySentences.length > 0) {
      summarySentences.forEach((sentence) => {
        lines.push(`- ${sentence}`)
      })
    } else {
      lines.push(`- ${structuredData.summary}`)
    }
  }

  // 亮点分支
  if (structuredData.highlights.length > 0) {
    lines.push('')
    lines.push('## 亮点')
    structuredData.highlights.forEach((highlight) => {
      const emoji = highlight.emoji || '✨'
      const timestamp = highlight.timestamp ? ` (${highlight.timestamp})` : ''
      lines.push(`- ${emoji} ${highlight.content}${timestamp}`)
    })
  }

  // 思考分支
  if (structuredData.reflections.length > 0) {
    lines.push('')
    lines.push('## 思考')
    structuredData.reflections.forEach((reflection) => {
      lines.push(`- ${reflection.question}`)
      const timestamp = reflection.timestamp ? ` (${reflection.timestamp})` : ''
      // 将答案按句号分割，每句作为子节点
      const answerSentences = reflection.answer
        .split(/[。！？\n]/)
        .map((s) => s.trim())
        .filter((s) => s.length > 0)
      if (answerSentences.length > 0) {
        answerSentences.forEach((sentence, index) => {
          if (index === answerSentences.length - 1 && timestamp) {
            lines.push(`  - ${sentence}${timestamp}`)
          } else {
            lines.push(`  - ${sentence}`)
          }
        })
      } else {
        lines.push(`  - ${reflection.answer}${timestamp}`)
      }
    })
  }

  // 术语解释分支
  if (structuredData.terms.length > 0) {
    lines.push('')
    lines.push('## 术语解释')
    structuredData.terms.forEach((term) => {
      lines.push(`- ${term.term}`)
      lines.push(`  - ${term.explanation}`)
    })
  }

  // 时间线总结分支
  if (structuredData.timeline.length > 0) {
    lines.push('')
    lines.push('## 时间线总结')
    structuredData.timeline.forEach((item) => {
      // 提取标题（第一行或第一个句子）
      const contentLines = item.content.split('\n\n')
      const title = contentLines[0] || item.content
      const description = contentLines.slice(1).join('\n\n')
      lines.push(`- ${item.timestamp} - ${title}`)
      if (item.screenshot) {
        lines.push(`  - ${item.screenshot}`)
      }
      if (description) {
        const descSentences = description
          .split(/[。！？\n]/)
          .map((s) => s.trim())
          .filter((s) => s.length > 0)
        descSentences.forEach((sentence) => {
          lines.push(`  - ${sentence}`)
        })
      }
    })
  }

  return lines.join('\n')
}
